-- PROTECTED WITH MOONSEC
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































--------------------------------------------
-- Detect Executor
--------------------------------------------
local executorName = "Unknown Executor"
if syn then
    executorName = "Synapse X"
elseif getexecutorname and type(getexecutorname()) == "string" then
    executorName = getexecutorname()
elseif isexecutor then
    executorName = "ScriptWare"
elseif KRNL_LOADED then
    executorName = "KRNL"
elseif fluxus then
    executorName = "Fluxus"
elseif is_sentinel_closure then
    executorName = "Sentinel"
end

--------------------------------------------
-- Load MacLib
--------------------------------------------
local MacLib = loadstring(game:HttpGet("https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt"))()

--------------------------------------------
-- Create the main window (700Ã—450)
--------------------------------------------
local Window = MacLib:Window({
    Title = "Comet [Beta]",
    Subtitle = "Free Build: v0.6 (" .. executorName .. ")",
    Size = UDim2.fromOffset(700, 450),
    DragStyle = 1,
    DisabledWindowControls = {},
    ShowUserInfo = false,
    Keybind = Enum.KeyCode.RightControl,
    AcrylicBlur = true,
    Logo = "rbxassetid://94627878655765",
})

--------------------------------------------
-- Create Tab Sections
--------------------------------------------
local Section1 = Window:TabGroup({ Name = "Section 1" }) -- Information, Farm, Blatant
local Section2 = Window:TabGroup({ Name = "Section 2" }) -- Teleport, Items
local Section3 = Window:TabGroup({ Name = "Section 3" }) -- Player, Extra

--------------------------------------------
-- Define Tabs
--------------------------------------------
local tabs = {}
tabs.Information = Section1:Tab({ Name = "Information", Image = "rbxassetid://116798752771500" })
tabs.Farm = Section1:Tab({ Name = "Farm", Image = "rbxassetid://74420346509159" })
tabs.Blatant = Section1:Tab({ Name = "Blatant", Image = "rbxassetid://82595512764783" })

tabs.Teleport = Section2:Tab({ Name = "Teleport", Image = "rbxassetid://138685837582982" })
tabs.Items = Section2:Tab({ Name = "Items", Image = "rbxassetid://114294642132368" })

tabs.Player = Section3:Tab({ Name = "Player", Image = "rbxassetid://93095625814079" })
tabs.Extra = Section3:Tab({ Name = "Extra", Image = "rbxassetid://91085936252450" })

--------------------------------------------
-- Services & Global Variables
--------------------------------------------
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- For selling
local autoSellEnabled = false
local sellMode = "Held Item"  -- "Held Item" => sell(false), "All At Once" => sell(true)
local sellDelay = 1

-- For dish
local autoDischEnabled = false
local autoHideEnabled = false

-- For auto time
local autoTimeEnabled = false
local autoTimeConnection = nil
local dishMode = "Fast"
local fastToleranceLarge = 47
local fastToleranceMedium = 17
local fastToleranceSmall = 10
local centeredTolerance = 3

-- For auto click
local autoClickEnabled = false
local clickSpeed = 0.1

-- Webhook
local _webhookURL = ""
local _webhookDelay = 10
local _autoWebhookEnabled = false

-- Appraise
local autoAppraiseEnabled = false

-- Held item detection
local heldItem = nil
local function onToolEquipped(tool)
    heldItem = tool
end
local function onToolUnequipped(tool)
    if heldItem == tool then
        heldItem = nil
    end
end
local function monitorCharacter(char)
    for _, child in ipairs(char:GetChildren()) do
        if child:IsA("Tool") then
            child.Equipped:Connect(onToolEquipped)
            child.Unequipped:Connect(onToolUnequipped)
        end
    end
    char.ChildAdded:Connect(function(c)
        if c:IsA("Tool") then
            c.Equipped:Connect(onToolEquipped)
            c.Unequipped:Connect(onToolUnequipped)
        end
    end)
end
if LocalPlayer.Character then
    monitorCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(monitorCharacter)

--------------------------------------------
-- INFORMATION TAB
--------------------------------------------
local InfoSectionLeft = tabs.Information:Section({ Name = "Info1", Side = "Left" })
InfoSectionLeft:Header({ Name = "Information" })
InfoSectionLeft:Paragraph({
    Header = "Comet",
    Body = "You are currently using the free version of Comet."
})
InfoSectionLeft:Paragraph({
    Header = "Executor API: " .. executorName,
    Body = "Your executor's API is supported!"
})
InfoSectionLeft:Paragraph({
    Header = "Version Info:",
    Body = "You are using the beta version of Comet\n- Current version is v0.6."
})
InfoSectionLeft:Paragraph({
    Header = "Anticheat Spoof:",
    Body = "There's no anticheat ðŸ’€"
})

local ChangelogSection = tabs.Information:Section({ Name = "Changelogs", Side = "Left" })
ChangelogSection:Header({ Name = "Changelog" })
ChangelogSection:Paragraph({
    Header = "Version 0.5 Updates",
    Body = "- Half way to v1!\n- Added Auto Hide\n- Added Webhooks\n- Rewritten Auto Disch"
})

local ContribSection = tabs.Information:Section({ Name = "Contributers", Side = "Right" })
ContribSection:Header({ Name = "Contributers" })
ContribSection:Paragraph({
    Header = "Credits",
    Body = "- whomiszack | Owner"
})

local LinksSection = tabs.Information:Section({ Name = "Links", Side = "Right" })
LinksSection:Header({ Name = "Links" })
LinksSection:Paragraph({
    Header = "Support",
    Body = "Areas to contact support"
})
LinksSection:Button({
    Name = "Copy Discord",
    Callback = function()
        setclipboard("https://discord.gg/yYMZJRYcZw")
        Window:Notify({ Title = "Discord", Description = "Discord invite copied!", Lifetime = 3 })
    end,
})

--------------------------------------------
-- FARM TAB
--------------------------------------------
local FarmSectionRight = tabs.Farm:Section({ Name = "Selling", Side = "Right" })
FarmSectionRight:Header({ Name = "Selling" })
FarmSectionRight:Toggle({
    Name = "Auto Sell",
    Default = false,
    Callback = function(state)
        autoSellEnabled = state
        if autoSellEnabled then
            spawn(function()
                while autoSellEnabled do
                    if sellMode == "Held Item" then
                        -- Held Item => sell(false)
                        ReplicatedStorage:WaitForChild("events"):WaitForChild("sell"):InvokeServer(false)
                    else
                        -- All At Once => sell(true)
                        ReplicatedStorage:WaitForChild("events"):WaitForChild("sell"):InvokeServer(true)
                    end
                    task.wait(sellDelay)
                end
            end)
        end
    end,
})
FarmSectionRight:Dropdown({
    Name = "Selling Mode",
    Options = {"Held Item", "All At Once"},
    Default = "Held Item",
    Callback = function(choice)
        sellMode = choice
    end,
})
FarmSectionRight:Slider({
    Name = "Sell Delay",
    Default = 1,
    Minimum = 1,
    Maximum = 30,
    Callback = function(value)
        sellDelay = value
    end,
})

local DishSection = tabs.Farm:Section({ Name = "Dish", Side = "Left" })
DishSection:Header({ Name = "Auto Disching" })
DishSection:Toggle({
    Name = "Auto Disch",
    Default = false,
    Callback = function(state)
        autoDischEnabled = state
        if autoDischEnabled then
            spawn(function()
                while autoDischEnabled do
                    local success, err = pcall(function()
                        local dischingObj = LocalPlayer:FindFirstChild("disching")
                        if dischingObj and dischingObj.Value then
                            -- Wait until disching becomes false
                            while autoDischEnabled and dischingObj and dischingObj.Value do
                                task.wait(0.1)
                                dischingObj = LocalPlayer:FindFirstChild("disching")
                            end
                        else
                            -- Teleport to a base position first
                            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(150, 13.25, 120)
                            end
                            task.wait(0.5)
                            
                            -- Build a list of available sinks
                            local availableSinks = {}
                            local restaurant = workspace:FindFirstChild("restaurant")
                            if restaurant then
                                local sinksFolder = restaurant:FindFirstChild("sinks")
                                if sinksFolder then
                                    for _, sink in ipairs(sinksFolder:GetChildren()) do
                                        if sink:IsA("Model") and string.lower(sink.Name) == "sink" then
                                            local part = sink.PrimaryPart or sink:FindFirstChildWhichIsA("BasePart")
                                            if part then
                                                local targetPos = part.Position
                                                local sinkClear = true
                                                for _, other in ipairs(Players:GetPlayers()) do
                                                    if other ~= LocalPlayer and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                                                        if (targetPos - other.Character.HumanoidRootPart.Position).Magnitude < 3 then
                                                            local dp = other:FindFirstChild("disching")
                                                            if dp and dp.Value then
                                                                sinkClear = false
                                                                break
                                                            end
                                                        end
                                                    end
                                                end
                                                if sinkClear then
                                                    table.insert(availableSinks, {position = targetPos, model = sink})
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            
                            local availableSinkData = nil
                            if #availableSinks > 0 then
                                lastUsedSinkIndex = (lastUsedSinkIndex or 0) + 1
                                if lastUsedSinkIndex > #availableSinks then
                                    lastUsedSinkIndex = 1
                                end
                                availableSinkData = availableSinks[lastUsedSinkIndex]
                            end
                            
                            if availableSinkData and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(availableSinkData.position)
                                local prompt = availableSinkData.model:FindFirstChildOfClass("ProximityPrompt")
                                if prompt then
                                    -- Continuously fire the proximity prompt until "disching" becomes true
                                    while autoDischEnabled do
                                        local dischingCheck = LocalPlayer:FindFirstChild("disching")
                                        if dischingCheck and dischingCheck.Value then break end
                                        fireproximityprompt(prompt)
                                        task.wait(0.1)
                                    end
                                else
                                    warn("ProximityPrompt not found in sink model")
                                end
                            end
                        end
                    end)
                    if not success then
                        warn("Auto Disch error: " .. tostring(err))
                    end
                    task.wait(0.5)
                end
            end)
        end
    end,
})

DishSection:Toggle({
    Name = "Auto Hide",
    Default = false,
    Callback = function(state)
        autoHideEnabled = state
        if autoHideEnabled then
            spawn(function()
                while autoHideEnabled do
                    local disching = LocalPlayer:FindFirstChild("disching")
                    if disching and disching.Value == true then
                        task.wait(0.5)
                        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(170.69, 57.50, -507.47)
                        end
                        while autoHideEnabled and (LocalPlayer:FindFirstChild("disching") and LocalPlayer.disching.Value == true) do
                            task.wait(0.1)
                        end
                        local sinkCoord = Vector3.new(150, 13.25, 120)
                        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(sinkCoord)
                        end
                    else
                        task.wait(0.1)
                    end
                end
            end)
        end
    end,
})
DishSection:Toggle({
    Name = "Auto Time",
    Default = false,
    Callback = function(state)
        autoTimeEnabled = state
        if autoTimeEnabled then
            autoTimeConnection = RunService.RenderStepped:Connect(function()
                local playerGui = LocalPlayer:WaitForChild("PlayerGui")
                local gameui = playerGui:FindFirstChild("gameui")
                if not gameui then return end
                local skillTest = gameui:FindFirstChild("skill test")
                if not (skillTest and skillTest.Visible) then return end
                local selectionArea = skillTest:FindFirstChild("selectionArea")
                if not selectionArea then return end

                local activeCircle
                for _, circle in ipairs(selectionArea:GetChildren()) do
                    if circle:IsA("ImageLabel") and circle.Visible then
                        activeCircle = circle
                        break
                    end
                end
                if not activeCircle then return end

                local selectionLine = skillTest:FindFirstChild("selectionLine")
                if not selectionLine then return end

                local circleName = activeCircle.Name:lower()
                local targetOffset = -35
                if circleName == "medium" then
                    targetOffset = -3
                elseif circleName == "small" then
                    targetOffset = 215
                end

                local tolerance
                if dishMode == "Fast" then
                    if circleName == "medium" then
                        tolerance = fastToleranceMedium
                    elseif circleName == "small" then
                        tolerance = fastToleranceSmall
                    else
                        tolerance = fastToleranceLarge
                    end
                else
                    tolerance = centeredTolerance
                end

                local circleRotation = (activeCircle.Rotation % 360 + 360) % 360
                local lineRotation = ((selectionLine.Rotation + targetOffset) % 360 + 360) % 360
                local diff = math.min(math.abs(circleRotation - lineRotation), 360 - math.abs(circleRotation - lineRotation))

                if diff <= tolerance then
                    local absPos = selectionLine.AbsolutePosition
                    local absSize = selectionLine.AbsoluteSize
                    local clickPos = Vector2.new(absPos.X + absSize.X/2, absPos.Y + absSize.Y/2)
                    VirtualInputManager:SendMouseButtonEvent(clickPos.X, clickPos.Y, 0, true, game, 0)
                    VirtualInputManager:SendMouseButtonEvent(clickPos.X, clickPos.Y, 0, false, game, 0)
                end
            end)
        else
            if autoTimeConnection then
                autoTimeConnection:Disconnect()
                autoTimeConnection = nil
            end
        end
    end,
})
DishSection:Dropdown({
    Name = "Time Mode",
    Options = {"Fast", "Centered"},
    Default = "Fast",
    Callback = function(choice)
        dishMode = choice
    end,
})
DishSection:Toggle({
    Name = "Auto Click",
    Default = false,
    Callback = function(state)
        autoClickEnabled = state
        if autoClickEnabled then
            spawn(function()
                while autoClickEnabled do
                    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
                    local gameui = playerGui:FindFirstChild("gameui")
                    if not gameui then task.wait(clickSpeed) continue end
                    local skillTest = gameui:FindFirstChild("skill test")
                    if not (skillTest and skillTest.Visible) then task.wait(clickSpeed) continue end
                    local backcircle = skillTest:FindFirstChild("backcircle")
                    if backcircle and backcircle.Visible then
                        local selectionLine = skillTest:FindFirstChild("selectionLine")
                        if selectionLine then
                            local absPos = selectionLine.AbsolutePosition
                            local absSize = selectionLine.AbsoluteSize
                            local clickPos = Vector2.new(absPos.X + absSize.X/2, absPos.Y + absSize.Y/2)
                            VirtualInputManager:SendMouseButtonEvent(clickPos.X, clickPos.Y, 0, true, game, 0)
                            VirtualInputManager:SendMouseButtonEvent(clickPos.X, clickPos.Y, 0, false, game, 0)
                        end
                    end
                    task.wait(clickSpeed)
                end
            end)
        end
    end,
})
DishSection:Slider({
    Name = "Click Speed",
    Default = 0.1,
    Minimum = 0.05,
    Maximum = 1,
    Precision = 2,
    Callback = function(value)
        clickSpeed = value
    end,
})

--------------------------------------------
-- BLATANT TAB
--------------------------------------------
local BlatantSection = tabs.Blatant:Section({ Name = "Blatant", Side = "Left" })
BlatantSection:Header({ Name = "Blatant" })
BlatantSection:Paragraph({
    Header = "Warning:",
    Body = "Warning: These scripts may only be available for higher-level executors!"
})
BlatantSection:Divider("----------")

local instantSolveActive = false
local clickLoopConnection = nil
local function applyAntiFail()
    for _, func in next, getgc(true) do
        if typeof(func) == "function" then
            local funcName = debug.info(func, "n")
            if funcName == "checkValidClick" then
                hookfunction(func, function()
                    return true
                end)
            end
        end
    end
end
BlatantSection:Toggle({
    Name = "Instant Solve",
    Default = false,
    Callback = function(state)
        instantSolveActive = state
        if instantSolveActive then
            applyAntiFail()
            clickLoopConnection = task.spawn(function()
                while instantSolveActive do
                    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
                    if playerGui then
                        local gameui = playerGui:FindFirstChild("gameui")
                        if gameui then
                            local skillTest = gameui:FindFirstChild("skill test")
                            if skillTest and skillTest.Visible then
                                local selectionLine = skillTest:FindFirstChild("selectionLine")
                                if selectionLine then
                                    local absPos = selectionLine.AbsolutePosition
                                    local absSize = selectionLine.AbsoluteSize
                                    local clickPos = Vector2.new(absPos.X + absSize.X/2, absPos.Y + absSize.Y/2)
                                    VirtualInputManager:SendMouseButtonEvent(clickPos.X, clickPos.Y, 0, true, game, 0)
                                    VirtualInputManager:SendMouseButtonEvent(clickPos.X, clickPos.Y, 0, false, game, 0)
                                end
                            end
                        end
                    end
                    task.wait(0.01)
                end
            end)
        else
            instantSolveActive = false
            clickLoopConnection = nil
        end
    end,
})

--------------------------------------------
-- PLAYER TAB
--------------------------------------------
local MovementSection = tabs.Player:Section({ Name = "Movement", Side = "Left" })
MovementSection:Header({ Name = "Movement" })
MovementSection:Slider({
    Name = "WalkSpeed",
    Default = 16,
    Minimum = 16,
    Maximum = 300,
    Callback = function(value)
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.WalkSpeed = value
        end
    end,
})
MovementSection:Slider({
    Name = "JumpPower",
    Default = 50,
    Minimum = 16,
    Maximum = 300,
    Callback = function(value)
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.UseJumpPower = true
            character.Humanoid.JumpPower = value
        end
    end,
})
MovementSection:Divider("----------")
MovementSection:Toggle({
    Name = "Flight",
    Default = false,
    Callback = function(enabled)
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if enabled then
            local bodyVelocity = Instance.new("BodyVelocity", hrp)
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            spawn(function()
                while enabled do
                    local moveDirection = character.Humanoid.MoveDirection
                    bodyVelocity.Velocity = moveDirection * 50
                    RunService.Stepped:Wait()
                end
            end)
        else
            for _, v in pairs(hrp:GetChildren()) do
                if v:IsA("BodyVelocity") then
                    v:Destroy()
                end
            end
        end
    end,
})
MovementSection:Toggle({
    Name = "Noclip",
    Default = false,
    Callback = function(enabled)
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        if enabled then
            _G.noclipConnection = RunService.Stepped:Connect(function()
                for _, v in pairs(character:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.CanCollide = false
                    end
                end
            end)
        else
            if _G.noclipConnection then
                _G.noclipConnection:Disconnect()
                _G.noclipConnection = nil
            end
            for _, v in pairs(character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = true
                end
            end
        end
    end,
})

local funStuffSection = tabs.Player:Section({ Name = "Fun Stuff", Side = "Right" })
funStuffSection:Header({ Name = "Fun Stuff" })

local moneyInputText = "0"
funStuffSection:Input({
    Name = "Money",
    Placeholder = "Enter amount",
    AcceptedCharacters = "All",
    Callback = function(text)
        moneyInputText = text
    end,
})
funStuffSection:Button({
    Name = "Give Money",
    Callback = function()
        local amount = tonumber(moneyInputText) or 0
        if LocalPlayer:FindFirstChild("leaderstats") and LocalPlayer.leaderstats:FindFirstChild("Money") then
            LocalPlayer.leaderstats.Money.Value = LocalPlayer.leaderstats.Money.Value + amount
        else
            Window:Notify({ Title = "Error", Description = "Money stat not found.", Lifetime = 3 })
        end
    end,
})
funStuffSection:Divider("----------")
local levelInputText = "0"
funStuffSection:Input({
    Name = "Amount",
    Placeholder = "Enter level amount",
    AcceptedCharacters = "All",
    Callback = function(text)
        levelInputText = text
    end,
})
funStuffSection:Button({
    Name = "Add Levels",
    Callback = function()
        local amount = tonumber(levelInputText) or 0
        if LocalPlayer:FindFirstChild("leaderstats") and LocalPlayer.leaderstats:FindFirstChild("Level") then
            LocalPlayer.leaderstats.Level.Value = LocalPlayer.leaderstats.Level.Value + amount
        else
            Window:Notify({ Title = "Error", Description = "Level stat not found.", Lifetime = 3 })
        end
    end,
})

--------------------------------------------
-- TELEPORT TAB (Separated Sections)
--------------------------------------------

-- 1) NPC / Area Teleports (Left)
local TeleportNPCSection = tabs.Teleport:Section({ Name = "NPC / Area Teleports", Side = "Left" })
TeleportNPCSection:Header({ Name = "NPC / Area Teleports" })

local tpSelectedNPC = "Hobo James"
local tpSelectedArea = "Sinks"

-- Predefined positions
local npcPositions = {
    ["Hobo James"] = Vector3.new(177.07, 13.34, 78.48),
    ["Supdoggy"] = Vector3.new(142.85, 13.24, 83.87),
    ["Hobo John (Item Seller)"] = Vector3.new(147.42, 13.24, 102.39),
    ["Frankie Fridge"] = Vector3.new(171.64, 13.25, 106.76),
    ["Index Issac"] = Vector3.new(185.19, 13.25, 108.91),
    ["Manager Mike"] = Vector3.new(186.23, 13.25, 119.30),
    ["Fat Filly"] = Vector3.new(153.04, 13.25, 142.18),
    ["Needy Steve"] = Vector3.new(160.36, 13.25, 164.61),
    ["Bathroom Bob (Appraiser)"] = Vector3.new(120.74, 13.19, 124.39)
}
local areaPositions = {
    ["Sinks"] = Vector3.new(156.71, 13.25, 121.48),
    ["Dining Area"] = Vector3.new(180.74, 13.25, 139.12),
    ["Bathroom"] = Vector3.new(126.95, 13.19, 122.75),
    ["Dumpster"] = Vector3.new(158.70, 13.24, 79.20)
}

TeleportNPCSection:Dropdown({
    Name = "NPCS",
    Options = {
        "Hobo James", "Supdoggy", "Hobo John (Item Seller)",
        "Frankie Fridge", "Index Issac", "Manager Mike",
        "Fat Filly", "Needy Steve", "Bathroom Bob (Appraiser)"
    },
    Default = "Hobo James",
    Callback = function(selected)
        tpSelectedNPC = selected
    end,
}, "NPCDropdown")

TeleportNPCSection:Dropdown({
    Name = "Areas",
    Options = { "Sinks", "Dining Area", "Bathroom", "Dumpster" },
    Default = "Sinks",
    Callback = function(selected)
        tpSelectedArea = selected
    end,
}, "AreaDropdown")

TeleportNPCSection:Button({
    Name = "Teleport NPC",
    Callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local position = npcPositions[tpSelectedNPC]
            if position then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(position)
            else
                Window:Notify({ Title = "Teleport", Description = "NPC position not found!", Lifetime = 3 })
            end
        else
            Window:Notify({ Title = "Teleport", Description = "Character or HRP not found!", Lifetime = 3 })
        end
    end,
})
TeleportNPCSection:Button({
    Name = "Teleport Area",
    Callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local position = areaPositions[tpSelectedArea]
            if position then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(position)
            else
                Window:Notify({ Title = "Teleport", Description = "Area position not found!", Lifetime = 3 })
            end
        else
            Window:Notify({ Title = "Teleport", Description = "Character or HRP not found!", Lifetime = 3 })
        end
    end,
})

-- 2) Player Teleport (Right)
local TeleportPlayerSection = tabs.Teleport:Section({ Name = "Player Teleport", Side = "Right" })
TeleportPlayerSection:Header({ Name = "Player Teleport" })

local tpPlayer = "None"
local playerDropdown = TeleportPlayerSection:Dropdown({
    Name = "Select Player",
    Options = { "None" },
    Default = "None",
    Callback = function(selected)
        tpPlayer = selected
    end,
}, "PlayerDropdown")

-- Dynamically update the Player dropdown
spawn(function()
    while true do
        local playersList = {}
        for _, p in ipairs(Players:GetPlayers()) do
            table.insert(playersList, p.Name)
        end

        playerDropdown:ClearOptions()
        playerDropdown:InsertOptions(playersList)

        task.wait(3)
    end
end)

TeleportPlayerSection:Divider("----------")
TeleportPlayerSection:Button({
    Name = "Teleport to Player",
    Callback = function()
        local targetPlayer = Players:FindFirstChild(tpPlayer)
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
           and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
        else
            Window:Notify({ Title = "Teleport", Description = "Player not found or missing HRP!", Lifetime = 3 })
        end
    end,
})

--------------------------------------------
-- ITEMS TAB
--------------------------------------------
-- Tools Section (Left)
local ToolsSection = tabs.Items:Section({ Name = "Tools Equip", Side = "Left" })
ToolsSection:Header({ Name = "Tools Equip" })
ToolsSection:Dropdown({
    Name = "Select Tool",
    Options = {
        "Hand", "Sticky Hand", "Chopsticks", "Grabber Claw", "Grappling Hook",
        "Plunger", "Your Cousins Arm", "Robo Arm", "Tentacle"
    },
    Default = "Hand",
    Callback = function(selectedTool)
        ReplicatedStorage:WaitForChild("events"):WaitForChild("toolEvent")
            :InvokeServer(string.lower(selectedTool), "equip")
    end,
}, "ToolDropdown")
ToolsSection:Divider("----------")
ToolsSection:Header({ Name = "Unreleased Tools! Are not functional!" })
ToolsSection:Dropdown({
    Name = "Unreleased Tools",
    Options = { "star rod", "umbrella rod", "triangle rod", "circle rod" },
    Default = "star rod",
    Callback = function(selectedTool)
        ReplicatedStorage:WaitForChild("events"):WaitForChild("toolEvent")
            :InvokeServer(string.lower(selectedTool), "equip")
    end,
}, "UnreleasedDropdown")

-- Appraise Section (Right)
local appraiseSection = tabs.Items:Section({ Name = "Appraise", Side = "Right" })
appraiseSection:Header({ Name = "Appraise" })
appraiseSection:Button({
    Name = "Appraise Held Item",
    Callback = function()
        if heldItem then
            ReplicatedStorage:WaitForChild("events"):WaitForChild("appraiseItem"):InvokeServer(heldItem)
            Window:Notify({ Title = "Appraise", Description = "Appraised: " .. heldItem.Name, Lifetime = 3 })
        else
            Window:Notify({ Title = "Appraise", Description = "No held item found.", Lifetime = 3 })
        end
    end,
})
appraiseSection:Divider("----------")
local function getBackpackItems()
    local bp = LocalPlayer:WaitForChild("Backpack")
    local items = {}
    for _, item in ipairs(bp:GetChildren()) do
        if item:IsA("Tool") then
            table.insert(items, item.Name)
        end
    end
    if #items == 0 then
        table.insert(items, "None")
    end
    return items
end
local selectedAppraiseItem = "None"
local appraiseDropdown = appraiseSection:Dropdown({
    Name = "Select Item",
    Options = getBackpackItems(),
    Default = "None",
    Callback = function(selected)
        selectedAppraiseItem = selected
    end,
}, "AppraiseDropdown")

spawn(function()
    while true do
        local newOptions = getBackpackItems()
        appraiseDropdown:ClearOptions()
        appraiseDropdown:InsertOptions(newOptions)

        local found = false
        for _, itemName in ipairs(newOptions) do
            if itemName == selectedAppraiseItem then
                found = true
                break
            end
        end
        if not found then
            selectedAppraiseItem = newOptions[1] or "None"
            appraiseDropdown:SetValue(selectedAppraiseItem)
        end

        task.wait(15)
    end
end)
appraiseSection:Toggle({
    Name = "Auto Appraise",
    Default = false,
    Callback = function(state)
        autoAppraiseEnabled = state
        if autoAppraiseEnabled then
            spawn(function()
                while autoAppraiseEnabled do
                    if selectedAppraiseItem and selectedAppraiseItem ~= "None" then
                        local tool = LocalPlayer.Backpack:FindFirstChild(selectedAppraiseItem)
                        if tool then
                            ReplicatedStorage:WaitForChild("events"):WaitForChild("appraiseItem"):InvokeServer(tool)
                        end
                    end
                    task.wait(0.5)
                end
            end)
        end
    end,
}, "AutoAppraiseToggle")

--------------------------------------------
-- EXTRA TAB
--------------------------------------------
local otherOptionsSection = tabs.Extra:Section({ Name = "Other Options", Side = "Left" })
otherOptionsSection:Header({ Name = "Other Options" })
otherOptionsSection:Toggle({
    Name = "PopUp Blocker",
    Default = false,
    Callback = function(value)
        if value then
            _G.popupBlockConnection = RunService.RenderStepped:Connect(function()
                local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
                if playerGui then
                    local passivegui = playerGui:FindFirstChild("passivegui")
                    if passivegui then
                        local doubleLuckPopup = passivegui:FindFirstChild("doubleLuckPopup")
                        if doubleLuckPopup and doubleLuckPopup.Visible then
                            doubleLuckPopup.Visible = false
                        end
                        local fastDishingPopup = passivegui:FindFirstChild("fastDishingPopup")
                        if fastDishingPopup and fastDishingPopup.Visible then
                            fastDishingPopup.Visible = false
                        end
                    end
                end
            end)
        else
            if _G.popupBlockConnection then
                _G.popupBlockConnection:Disconnect()
                _G.popupBlockConnection = nil
            end
        end
    end,
})
otherOptionsSection:Toggle({
    Name = "Notification Blocker",
    Default = false,
    Callback = function(value)
        if value then
            _G.notificationBlockConnection = RunService.RenderStepped:Connect(function()
                local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
                if playerGui then
                    local gameui = playerGui:FindFirstChild("gameui")
                    if gameui then
                        local unlockedShowcase = gameui:FindFirstChild("unlockedShowcase")
                        if unlockedShowcase and unlockedShowcase.Visible then
                            unlockedShowcase.Visible = false
                        end
                        local unlockedPopupText = gameui:FindFirstChild("unlockedPopupText")
                        if unlockedPopupText and unlockedPopupText.Visible then
                            unlockedPopupText.Visible = false
                        end
                        local fastDishingButton = gameui:FindFirstChild("fastDishingButton")
                        if fastDishingButton and fastDishingButton.Visible then
                            fastDishingButton.Visible = false
                        end
                    end
                end
            end)
        else
            if _G.notificationBlockConnection then
                _G.notificationBlockConnection:Disconnect()
                _G.notificationBlockConnection = nil
            end
        end
    end,
})

-- Webhook (Right)
local webhookSectionExtra = tabs.Extra:Section({ Name = "Webhook", Side = "Right" })
webhookSectionExtra:Header({ Name = "Webhook" })
webhookSectionExtra:Header({ Name = "Open a ticket in Discord for help configuring." })
webhookSectionExtra:Divider("----------")
webhookSectionExtra:Input({
    Name = "Webhook URL",
    Placeholder = "Enter your webhook URL",
    Callback = function(text)
        _webhookURL = text or ""
    end,
}, "WebhookURLInput")
webhookSectionExtra:Slider({
    Name = "Webhook Delay (sec)",
    Default = 10,
    Minimum = 1,
    Maximum = 60,
    Callback = function(value)
        _webhookDelay = value
    end,
}, "WebhookDelaySlider")
local function sendWebhookMessage()
    if _webhookURL ~= "" then
        local data = { content = "Auto webhook message from Comet [Beta]" }
        local jsonData = HttpService:JSONEncode(data)
        pcall(function()
            HttpService:PostAsync(_webhookURL, jsonData, Enum.HttpContentType.ApplicationJson)
        end)
    end
end
webhookSectionExtra:Toggle({
    Name = "Auto Webhook",
    Default = false,
    Callback = function(value)
        _autoWebhookEnabled = value
        if _autoWebhookEnabled then
            spawn(function()
                while _autoWebhookEnabled do
                    sendWebhookMessage()
                    task.wait(_webhookDelay)
                end
            end)
        end
    end,
}, "AutoWebhookToggle")

-- Hide Identity (Left)
local hideIdentitySection = tabs.Extra:Section({ Name = "Hide Identity", Side = "Left" })
hideIdentitySection:Header({ Name = "Hide Identity" })
local fakeDisplay = "AmySchumer"
hideIdentitySection:Input({
    Name = "Display",
    Placeholder = "Enter fake display name",
    Callback = function(text)
        fakeDisplay = text
    end,
})
local fakeUsername = "redmiint8"
hideIdentitySection:Input({
    Name = "Username",
    Placeholder = "Enter fake username",
    Callback = function(text)
        fakeUsername = text
    end,
})
local fakeUserId = "13886182"
hideIdentitySection:Input({
    Name = "User ID",
    Placeholder = "Enter fake user ID",
    AcceptedCharacters = "Numeric",
    Callback = function(text)
        fakeUserId = text
    end,
})
hideIdentitySection:Divider("----------")
hideIdentitySection:SubLabel({
    Text = "Cannot be disabled once enabled"
})
local function hideIdentity()
    if not getgenv().Config then
        getgenv().Config = {}
    end
    getgenv().Config.Headless = false
    getgenv().Config.FakeDisplayName = fakeDisplay
    getgenv().Config.FakeName = fakeUsername
    getgenv().Config.FakeId = tonumber(fakeUserId)

    local players = game:GetService("Players")
    local function disguisechar(char, id)
        task.spawn(function()
            if not char then return end
            local hum = char:FindFirstChildOfClass('Humanoid')
            char:WaitForChild("Head")
            local desc
            if desc == nil then
                local suc = false
                repeat
                    suc = pcall(function()
                        desc = players:GetHumanoidDescriptionFromUserId(id)
                    end)
                    task.wait(1)
                until suc
            end
            desc.HeightScale = hum:WaitForChild("HumanoidDescription").HeightScale
            char.Archivable = true
            local disguiseclone = char:Clone()
            disguiseclone.Name = "disguisechar"
            disguiseclone.Parent = workspace
            for i, v in pairs(disguiseclone:GetChildren()) do
                if v:IsA("Accessory") or v:IsA("ShirtGraphic") or v:IsA("Shirt") or v:IsA("Pants") then
                    v:Destroy()
                end
            end
            disguiseclone.Humanoid:ApplyDescriptionClientServer(desc)
            for i, v in pairs(char:GetChildren()) do
                if (v:IsA("Accessory") and v:GetAttribute("InvItem") == nil and v:GetAttribute("ArmorSlot") == nil)
                   or v:IsA("ShirtGraphic") or v:IsA("Shirt") or v:IsA("Pants") or v:IsA("BodyColors") then
                    v.Parent = game
                end
            end
            char.ChildAdded:Connect(function(v)
                if ((v:IsA("Accessory") and v:GetAttribute("InvItem") == nil and v:GetAttribute("ArmorSlot") == nil)
                   or v:IsA("ShirtGraphic") or v:IsA("Shirt") or v:IsA("Pants") or v:IsA("BodyColors")) and v:GetAttribute("Disguise") == nil then
                    repeat
                        task.wait()
                        v.Parent = game
                    until v.Parent == game
                end
            end)
            for i, v in pairs(disguiseclone:WaitForChild("Animate"):GetChildren()) do
                v:SetAttribute("Disguise", true)
                local real = char.Animate:FindFirstChild(v.Name)
                if v:IsA("StringValue") and real then
                    real.Parent = game
                    v.Parent = char.Animate
                end
            end
            for i, v in pairs(disguiseclone:GetChildren()) do
                v:SetAttribute("Disguise", true)
                if v:IsA("Accessory") then
                    for i2, v2 in pairs(v:GetDescendants()) do
                        if v2:IsA("Weld") and v2.Part1 then
                            v2.Part1 = char[v2.Part1.Name]
                        end
                    end
                    v.Parent = char
                elseif v:IsA("ShirtGraphic") or v:IsA("Shirt") or v:IsA("Pants") or v:IsA("BodyColors") then
                    v.Parent = char
                elseif v.Name == "Head" and v:FindFirstChildOfClass('SpecialMesh') then
                    char.Head:FindFirstChildOfClass('SpecialMesh').MeshId = v:FindFirstChildOfClass('SpecialMesh').MeshId
                end
            end
            local localface = char:FindFirstChild("face", true)
            local cloneface = disguiseclone:FindFirstChild("face", true)
            if localface and cloneface then
                localface.Parent = game
                cloneface.Parent = char.Head
            end
            char.Humanoid.HumanoidDescription:SetEmotes(desc:GetEmotes())
            char.Humanoid.HumanoidDescription:SetEquippedEmotes(desc:GetEquippedEmotes())
            disguiseclone:Destroy()
        end)
    end

    local lp = players.LocalPlayer
    local oldUserId = tostring(lp.UserId)
    local oldName = lp.Name
    local oldDisplayName = lp.DisplayName

    local function processtext(text)
        if string.gsub(text, oldName, getgenv().Config.FakeName) ~= text then
            return string.gsub(text, oldName, getgenv().Config.FakeName)
        elseif string.gsub(text, oldUserId, tostring(getgenv().Config.FakeId)) ~= text then
            return string.gsub(text, oldUserId, tostring(getgenv().Config.FakeId))
        elseif string.gsub(text, oldDisplayName, getgenv().Config.FakeDisplayName) ~= text then
            return string.gsub(text, oldDisplayName, getgenv().Config.FakeDisplayName)
        end
        if text ~= nil then
            return text
        end
        return ''
    end

    for i, v in next, game:GetDescendants() do
        if v:IsA("TextBox") or v:IsA("TextLabel") or v:IsA("TextButton") then
            v.Text = processtext(v.Text)
            v.Name = processtext(v.Name)
            v.Changed:Connect(function()
                v.Text = processtext(v.Text)
                v.Name = processtext(v.Name)
            end)
        end
    end
    game.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("TextBox") or descendant:IsA("TextLabel") or descendant:IsA("TextButton") then
            descendant.Text = processtext(descendant.Text)
            descendant.Name = processtext(descendant.Name)
            descendant.Changed:Connect(function()
                descendant.Text = processtext(descendant.Text)
                descendant.Name = processtext(descendant.Name)
            end)
        end
    end)

    lp.DisplayName = getgenv().Config.FakeDisplayName
    lp.CharacterAppearanceId = getgenv().Config.FakeId

    if getgenv().Config.Headless == true then
        task.spawn(function()
            while task.wait() do
                local char = lp.Character or lp.CharacterAdded:Wait()
                char:WaitForChild("Head").Transparency = 1
                if char:WaitForChild("Head"):FindFirstChildOfClass("Decal") then
                    char.Head:FindFirstChildOfClass("Decal"):Destroy()
                end
            end
        end)
    end

    pcall(function()
        disguisechar(lp.Character, getgenv().Config.FakeId)
    end)

    lp.CharacterAdded:Connect(function()
        disguisechar(lp.Character, getgenv().Config.FakeId)
    end)
end

hideIdentitySection:Button({
    Name = "Enable Hide Identity",
    Callback = function()
        hideIdentity()
    end,
})

--------------------------------------------
-- MacLib Settings
--------------------------------------------
MacLib:SetFolder("Maclib")
tabs.Information:Select()  -- Select the Information tab by default
